import streamlit as st
import time
import pandas as pd
import requests
import psutil

# Set Streamlit page configuration
st.set_page_config(
    page_title='Smart Dashboard',
    layout="wide",
    menu_items={"About": "Smart Dashboard for real-time and historical data monitoring"}
)

with st.sidebar:
    st.title("Navigation")
    page = st.radio("Go to:", ["Dashboard", "Weather Data", "Historical Analysis", "Performance Overview"])

# Load dataset and handle errors
try:
    df = pd.read_csv("demo_data.csv")
except FileNotFoundError:
    st.error("Data file 'demo_data.csv' not found. Please ensure it is in the correct directory.")
    st.stop()
except Exception as e:
    st.error(f"An error occurred while loading the data: {e}")
    st.stop()

# Dashboard Page
if page == "Dashboard":
    st.header("Real-time Dashboard")

    # Voltage Threshold
    st.markdown("### Voltage Threshold")
    voltage_threshold = st.slider("Set Voltage Threshold", min_value=0.0, max_value=300.0, step=0.1, value=220.0)
    st.write(f"Current Voltage Threshold: {voltage_threshold} V")

    # Track whether warning has been shown
    warning_shown = False  # This will store the state of the warning

    # Initialize columns for charts
    col1, col2, col3 = st.columns(3)
    col4, col5, col6 = st.columns(3)

    # Define subheaders for real-time charts
    col1.subheader("Voltage [V] and Current")
    Voltage = col1.line_chart({"Voltage": [], "Current": []})

    col2.subheader("Frequency")
    Freq = col2.line_chart({"Measured_Frequency": []})

    col3.subheader("Power Data")
    AP = col3.line_chart({
        "Active_Power": [], "Reactive_Power": [], "Apperent_Power": []
    })

    col4.subheader("Angle Data")
    PA = col4.line_chart({
        "Phase_Voltage_Angle": []
    })

    col5.subheader("Cos Phi Data")
    CP = col5.line_chart({"Cos_Phi": []})

    col6.subheader("Power Factor Data")
    PF = col6.line_chart({"Power_Factor": []})

    # Placeholder for Date and Time metrics
    YMDt = st.empty()
    Tt = st.empty()

    # Real-time Updates for Charts
    def update_real_time_charts(row):
        updated_columns = {}

        if "Voltage" in row and "Current" in row:
            Voltage.add_rows([{"Voltage": row["Voltage"], "Current": row["Current"]}])
            updated_columns["Voltage"] = row["Voltage"]
            updated_columns["Current"] = row["Current"]

        if "Measured_Frequency" in row:
            Freq.add_rows([{"Measured_Frequency": row["Measured_Frequency"]}])
            updated_columns["Measured_Frequency"] = row["Measured_Frequency"]

        if all(k in row for k in ["Active_Power", "Reactive_Power", "Apperent_Power"]):
            AP.add_rows([{
                "Active_Power": row["Active_Power"],
                "Reactive_Power": row["Reactive_Power"],
                "Apperent_Power": row["Apperent_Power"]
            }])
            updated_columns["Active_Power"] = row["Active_Power"]
            updated_columns["Reactive_Power"] = row["Reactive_Power"]
            updated_columns["Apperent_Power"] = row["Apperent_Power"]

        if "Phase_Voltage_Angle" in row:
            PA.add_rows([{"Phase_Voltage_Angle": row["Phase_Voltage_Angle"]}])
            updated_columns["Phase_Voltage_Angle"] = row["Phase_Voltage_Angle"]

        if "Cos_Phi" in row:
            CP.add_rows([{"Cos_Phi": row["Cos_Phi"]}])
            updated_columns["Cos_Phi"] = row["Cos_Phi"]

        if "Power_Factor" in row:
            PF.add_rows([{"Power_Factor": row["Power_Factor"]}])
            updated_columns["Power_Factor"] = row["Power_Factor"]

        return updated_columns

    # Track updated columns
    all_updated_columns = {}
    for _, row in df.iterrows():
        updated_columns = update_real_time_charts(row)
        all_updated_columns.update(updated_columns)

        # Voltage Threshold Check
        if "Voltage" in row and row["Voltage"] > voltage_threshold and not warning_shown:
            st.warning(f"Voltage exceeded threshold! Current Voltage: {row['Voltage']} V")
            warning_shown = True  # Set the warning flag to True

        # Reset warning once voltage drops below threshold
        if "Voltage" in row and row["Voltage"] <= voltage_threshold and warning_shown:
            warning_shown = False  # Reset the flag to False

        if "Date" in row:
            YMDt.metric("Date", row["Date"])
        if "Time" in row:
            Tt.metric("Time", row["Time"])
        time.sleep(0.1)

    # Display updated columns
    st.subheader("Updated Columns with Last Known Values")
    formatted_updated_columns = [{"Column": col, "Last Known Value": value} for col, value in all_updated_columns.items()]
    st.table(pd.DataFrame(formatted_updated_columns))

# Weather Data Page
elif page == "Weather Data":
    st.header("Weather Data")
    try:
        weather = requests.get("https://api.open-meteo.com/v1/forecast?latitude=35&longitude=139&hourly=temperature_2m").json()
        st.write("Temperature (Â°C):", weather["hourly"]["temperature_2m"][:5])
    except Exception as e:
        st.error(f"Unable to fetch weather data: {e}")

# Historical Analysis Page
elif page == "Historical Analysis":
    st.header("Historical Data Analysis")
    df['Time'] = pd.to_datetime(df['Time'], errors='coerce').dt.time
    start_time = st.time_input("Start Time", value=df["Time"].min())
    end_time = st.time_input("End Time", value=df["Time"].max())
    df_filtered = df[(df["Time"] >= start_time) & (df["Time"] <= end_time)]

    # Display historical data charts
    chart_col1, chart_col2 = st.columns(2)
    chart_col1.subheader("Voltage [V] and Current")
    chart_col1.line_chart(df_filtered[["Voltage", "Current"]])

    chart_col2.subheader("Power Data (Active, Reactive, Apparent)")
    chart_col2.line_chart(df_filtered[["Active_Power", "Reactive_Power", "Apperent_Power"]])

    st.markdown("### Summary of Selected Data Range")
    st.write(df_filtered.describe())

    # Display filtered data
    st.write("Filtered Data:")
    st.dataframe(df_filtered)

# Performance Overview Page
elif page == "Performance Overview":
    st.header("Performance Monitor")
    perf_col1, perf_col2, perf_col3 = st.columns(3)

    # Initialize charts for performance metrics
    cpu_chart = perf_col1.line_chart({"CPU Usage": []})
    memory_chart = perf_col2.line_chart({"Memory Usage": []})
    disk_chart = perf_col3.line_chart({"Disk Usage": []})

    # System performance overview
    with st.expander("System performance overview"):
        cpu_usage = psutil.cpu_percent(interval=0.1)
        memory_info = psutil.virtual_memory()
        disk_usage = psutil.disk_usage('/')
        net_io = psutil.net_io_counters()

        st.write(f"**CPU usage:** {cpu_usage}%")
        st.write(f"**RAM usage:** {memory_info.percent}%")
        st.write(f"**Total RAM memory:** {memory_info.total / (1024 ** 3):.2f} GB")
        st.write(f"**Available RAM memory:** {memory_info.available / (1024 ** 3):.2f} GB")
        st.write(f"**Disk usage:** {disk_usage.percent}%")
        st.write(f"**Total space on the Disk:** {disk_usage.total / (1024 ** 3):.2f} GB")
        st.write(f"**Available memory on Disk:** {disk_usage.free / (1024 ** 3):.2f} GB")
        st.write(f"**Sent data:** {net_io.bytes_sent / (1024 ** 2):.2f} MB")
        st.write(f"**Data received:** {net_io.bytes_recv / (1024 ** 2):.2f} MB")

    # Continuous performance metrics update
    for _ in range(100):
        cpu_chart.add_rows({"CPU Usage": [psutil.cpu_percent()]})
        memory_chart.add_rows({"Memory Usage": [psutil.virtual_memory().percent]})
        disk_chart.add_rows({"Disk Usage": [psutil.disk_usage('/').percent]})
        time.sleep(0.1)

